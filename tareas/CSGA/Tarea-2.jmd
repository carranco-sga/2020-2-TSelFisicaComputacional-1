
# Tarea 2




> Envío inicial del PR: **27 de marzo**.
>
> Aceptación PR *final*: **3 de abril**.

**NOTA**: Esta tarea incluye generar varias imágenes; no es necesario que las incluyan en su entrega, pero sí debe ser posible generarlas a partir de lo que entreguen.

## Ejercicio 1

Describan la dinámica de varias órbitas para los siguientes mapeos, usando distintos colores para distintas órbitas, en una misma gráfica. Interesa entre otras cosas saber cuántos puntos fijos tiene el mapeo y cómo es la dinámica cerca de dichos puntos.

Definamos algunas herramientas para poder estudiar mapeos, por ejemplo: 

- una función que calcule el arreglo de $n$ iterados bajo un mapeo $f$ con condición inicial $x_0$; y,
- una función que calcule la $n$-ésima iteración bajo un mapeo $f$ de una condición inicial $x_0$.

Para tener algo de flexibilidad al momento de aplicar las funciones (pudiendo utilizar mapeos de $\mathbb{R}^n$ o inclusive $\mathbb{C}^n$ en si mismos, pidamos solamente que $f$ sea un mapeo (una función) y $n$ sea un entero no negativo. ($n = 0$, por convención, definamos que corresponde al mapeo identidad.)

```julia
"""
    iterados(f::Function, n::T, x0) where {T <: Integer}

Función que dado un mapeo \$f\$ y una condición inicial \$x_0\$, devuelve el vector \$(x_0, f(x_0), \\ldots, f^{(n)}(x_0)\$.
\$f\$ debe tener dominio y codominio iguales.
"""
function iterados(f::Function, n::T, x0) where {T <: Integer}
    
    @assert n >= 0
    
    iterados = fill(x0, n + 1)
    
    for i in 1:n
        
        iterados[i + 1] = f(iterados[i])
    end
    
    return iterados
end

"""
    iterados(f::Function, n::T) where {T <: Integer}

Forma funcional de ```iterados(f, n, x0)``` que permite variar la condición inicial \$x_0\$.
"""
iterados(f::Function, n::T) where {T <: Integer} = x0 -> iterados(f, n, x0)

"""
    iterar(f::Function, n::T, x0) where {T <: Integer}

Función que dado un mapeo \$f\$ y una condición inicial \$x_0\$, devuelve el resultado de iterar \$f\$ en \$x_0\$, \$n\$ veces.
Los valores intermedios son  usados para el cálculo, pero no son almacenados.
"""
function iterar(f::Function, n::T, x0) where {T <: Integer}
    
    @assert n >= 0
    
    x = x0
    
    for i in 1:n
        
        x = f(x) 
    end
    
    return x
end

"""
    iterar(f::Function, n::T) where {T <: Integer}

Forma funcional de ```iterar(f, n, x0)``` que permite variar la condición inicial \$x_0\$.
"""
iterar(f::Function, n::T) where {T <: Integer} = x0 -> iterar(f, n, x0)
```

Hagamos algunas pruebas para verificar el funcionamiento de los métodos y compararlos:

```julia
#Para medir adecuadamente el tiempo de ejecución en Julia, requerimos correr la función por primera vez para quitar el tiempo de compilación.
#Una herramienta para hacer benchmarks es BenchmarkTools y su correspondiente macro, @benchmark:
using BenchmarkTools

#Para cuando guardamos los iterados intermedios:
@benchmark iterados(x -> x*(1 - x), 10, 0.5)
@benchmark iterados(x -> x*(1 - x), 1000, 0.5)
```

```julia
#Y para cuando usamos una variable local que vamos actualizando:
@benchmark iterar(x -> x*(1 - x), 10, 0.5)
@benchmark iterar(x -> x*(1 - x), 1000, 0.5)
```

Como se puede ver del ejemplo, el hecho de guardar la trayectoria del punto inicial bajo las iteraciones con el mapeo aumenta tanto la memoria usada como el tiempo de cómputo. Sin embargo, ésto es a costa de la información que guardamos.

Para poder implementar el análisis gráfico, requerimos cargar un módulo para graficar. Por simplicidad, utilicemos ```Plots.jl``` con el backend ```pyplot```:

```julia
#Cargamos Plots:
using Plots; pyplot()
```

Dado que vamos a graficar varios segmentos de recta, nos conviene poder generarlos de forma sencilla.
Una manera de hacer ésto es mediante la forma paramétrica de la línea que pasa entre dos puntos:

```julia
"""
    línea_paramétrica(x1, x2)

Forma paramétrica de la línea que pasa por \$x_1\$ y \$x_2\$.
Devuelve una función que depende del parámetro real \$t\$.
El segmento de recta comprendido entre \$x_1\$ y \$x_2\$ está parametrizado por \$t \\in [0, 1]\$.

Porque esta forma es lineal, la forma paramétrica de las coordenadas de la recta entre ambos puntos se pueden obtener de esta función utilizando las coordenadas de los puntos respectivas en su lugar.
"""
línea_paramétrica(x1, x2) = t -> (x2 - x1)*t + x1

"""
    puntos_línea(x1, x2, ts)

Devuelve el conjunto de puntos de la línea que pasa por \$x_1\$ y \$x_2\$ resultado de evaluar la forma paramétrica de la línea en el conjunto de puntos ```ts```.
"""
puntos_línea(x1, x2, ts) = línea_paramétrica(x1, x2).(ts)
```

Asimismo, nos conviene definir una función que haga un paso del análisis gráfico, correspondiente en graficar las líneas que van del punto de la curva de la función a la identidad y de allí a la imagen del punto original bajo la función:

```julia
"""
    análisis_iterado!(gráfica, x, fx, ffx, ts; linecolor = :green)

Dada una ```gráfica```, agrega a la misma los segmentos de línea entre los puntos \$(x, f(x))\$ y \$(f(x), f(x))\$, y \$(f(x), f(x))\$ y \$(f(x), f^{(2)}(x))\$.
Éstos segmentos corresponden a la representación de una iteración de \$f\$ con condición inicial \$x_0\$ en dos dimensiones.
Los segmentos incorporados tienen el color ```linecolor```.
"""
function análisis_iterado!(gráfica, x, fx, ffx, ts; linecolor = :green)
    
    x_fx_x = puntos_línea(x, fx, ts)
    x_fx_y = puntos_línea(fx, fx, ts)
    fx_ffx_x = x_fx_y
    fx_ffx_y = puntos_línea(fx, ffx, ts)
    
    plot!(gráfica, x_fx_x, x_fx_y, label = "", linecolor = linecolor, linestyle = :dash)
    plot!(gráfica, fx_ffx_x, fx_ffx_y, label = "", linecolor = linecolor, linestyle = :dash)
end
```

Para poder comparar diferentes condiciones iniciales, nos conviene implementar un método que agregue a una gráfica dada el análisis gráfico de una única condición inicial:

```julia
"""
    análisis_gráfico!(gráfica, f, n, x0; ts = 0:0.01:1, linecolor = :green)

Dado un mapeo \$f\$, un número de iteraciones \$n\$ y una condición inicial, \$x_0\$, genera el análisis gráfico correspondiente sobre la ```gráfica``` dada.
Los segmentos respectivos son mostrados en color ```linecolor``` y son muestreadas en los valores del parámetro ```ts```.
Se devuelve el máximo y el mínimo de los valores de los iterados para determinar los límites de graficación.
"""
function análisis_gráfico!(gráfica, f, n, x0; ts = 0:0.1:1, linecolor = :green)
    
    #Calculamos los iterados solicitados:    
    vector_iterados = iterados(f, n, x0)
    
    #Obtenemos el máximo y el mínimo:
    máx = maximum(vector_iterados)
    mín = minimum(vector_iterados)
      
    #El primer iterado:
    x = vector_iterados[1]
    fx = vector_iterados[2]
    x_fx_x = puntos_línea(x, x, ts)
    x_fx_y = puntos_línea(0, fx, ts)
        
    plot!(gráfica, x_fx_x, x_fx_y, label = "", linecolor = linecolor, linestyle = :dash)
        
    #Y los demás, basados en la identidad:
    for i in 1:(n - 1)
    
        análisis_iterado!(gráfica, vector_iterados[i:(i + 2)]..., ts, linecolor = linecolor)
    end
        
    return mín, máx
end
```

Finalmente, podemos empaquetar el método anterior, considerar los límites de la gráfica e incorporar las gráficas de la función y de la identidad en un sólo método:

```julia
"""
    análisis_gráfico(f, n, x0s; paso = 0.1, linecolors = nothing)

Dado un mapeo \$f\$, un número de iteraciones \$n\$ y un arreglo de condiciones iniciales, ```x0s```, genera el análisis gráfico correspondiente.
Opcionalmente, se pueden especificar el tamaño de ```paso``` usado y el color de la órbita de cada condición inicial.
"""
function análisis_gráfico(f, n, x0s; paso = 0.1, linecolors = nothing)
    
    gráfica = plot()
    
    #Puntos para calcular las líneas:
    ts = 0:paso:1
    
    #Arrays para guardar valores límites:
    extremos = []
    
    #Definimos los colores de los iterados como fallback:
    if isnothing(linecolors)
        
        linecolors = fill(:green, length(x0s))
    end
    
    #Iteramos sobre las condiciones iniciales:
    for i in eachindex(x0s)
        
        mín, máx = análisis_gráfico!(gráfica, f, n, x0s[i]; ts = ts, linecolor = linecolors[i])
        
        push!(extremos, mín)
        push!(extremos, máx)
    end
    
    #Límites de las gráfica:
    xmín = minimum(extremos)
    xmáx = maximum(extremos)
    
    #Graficamos las funciones
    #Incorporamos más pasos al dominio de las funciones:
    xs = xmín:0.1*paso:xmáx
    
    plot!(gráfica, xs, x -> x, label = "Id", legend = :outerright, linecolor = :blue)
    plot!(gráfica, xs, f, label = "Función", linecolor = :red)
        
    return gráfica
end
```

(a) $M_1(x) = \frac{1}{3x}$.

Para el primer ejercicio, definamos la función:

```julia
M₁(x) = 1/(3*x)
```

Tomemos como condiciones iniciales:

```julia
n_1 = 4
x0s_1 = [0.1:0.2:0.9...]
```

Podemos usar la paleta de colores por [defecto](https://discourse.julialang.org/t/way-to-get-default-color-order-in-plots-jl/12643).
Para usar ésto posteriormente, definamos una función auxiliar que nos de una paleta del número de colores que requerimos:

```julia
paleta_colores(l) =  get_color_palette(:auto, plot_color(:white), l)
```

Usando ésto, podemos proceder al análisis gráfico:

```julia
colores_1 = paleta_colores(length(x0s_1))

análisis_gráfico(M₁, n_1, x0s_1, linecolors = colores_1)
```

Por completitud, realicemos el análisis en la rama negativa:

```julia
análisis_gráfico(M₁, n_1, -x0s_1, linecolors = colores_1)
```

De las gráficas se observa que hay dos puntos fijos: $x_0 = \pm 1$.
Algebráicamente es sencillo demostrar que éstos son los únicos puntos fijos reales del mapeo:

$$ M_1(x) = x \iff \frac{1}{3x} = x \implies 3x^2 = 1 \iff x_0 = \pm \frac{\sqrt{3}}{3} \approx \pm 0.5773. $$

Adicionalmente, vemos que todo punto del dominio de $f$ menos los puntos fijos generan una órbita estable de periodo 2.
Esto se puede ver de la siguiente forma:

$$ M_1^{(2)}(x) = M_1(M_1(x)) = \frac{1}{3f(x)} = \frac{1}{3\left(\frac{1}{3x}\right)} = x. $$

Claramente dos es el mínimo periodo.

(b) $M_2(x) = -\frac{x^5}{5}$.

Procedemos análogamente:

```julia
M₂(x) = -x^5/5

n_2 = 4
x0s_2 = [-1.5:0.1:1.5...]

colores_2 = paleta_colores(length(x0s_2))

gráfica_2 = análisis_gráfico(M₂, n_2, x0s_2, linecolors = colores_2)
xlims!(-5, 5)
ylims!(-5, 5)
```

Observamos inmediatamente que existe un punto fijo atractor en $x_0 = 0$. Sin embargo, cuando $x_0 = \pm 1.5$, las órbitas cambian de comportamiento y empiezan a diverger.
La recta identidad sólo interseca la función en $x_0 = 0$, por lo que el cambio de comportamiento no se puede entender en términos de un punto fijo (real).

Podemos, sin realizar un análisis en los complejos, determinar la región de atracción del punto fijo fijándonos en la norma del primer iterado.
Sabemos que una condición necesaria y suficiente para que la sucesión $\{x^n\}$ converja es que $|x| \leq 1$, por lo que la región de atracción del punto fijo es:

$$ |M_2(x)| = \frac{|x|^5}{5} \leq 1 \iff |x| \leq 5^\frac{1}{5} \approx 1.3792. $$

(c) $M_3(x) = \frac{x}{2}-2$.

Análogamente:

```julia
M₃(x) = x/2 - 2

n_3 = 4
x0s_3 = [-10:0.5:1...]

colores_3 = paleta_colores(length(x0s_3))

gráfica_3 = análisis_gráfico(M₃, n_3, x0s_3, linecolors = colores_3)
```

Observamos que existe un único punto atractor, $x_0 = 4$.
La unicidad se desprende inmediatamente de aplicar la definición de punto fijo y el teorema fundamental del álgebra:

$$M_3(x) = x \iff \frac{x}{2} - 2 = x \iff x_0 = 4.$$


La región de atracción del punto fijo es infinita. Esto se puede ver acotando la distancia entre el primer iterado y el punto atractor con la distancia de la condición inicial al punto atractor:

$$ d(M_3(x), -4) = |M_3(x) - (-4)| = \left|\frac{x}{2} - 2 + 4\right| = \left|\frac{x}{2} + 2 \right| = \frac{|x + 4|}{2} \leq |x - (-4)| = d(x, -4).$$

(I.e. el iterado siempre queda tan lejos o tan cerca como la condición inicial. 
Dado que la única forma en que la mitad de un número sea exactamente igual al número es  que el número sea cero, quitando el punto atractor, la desigualdad se vuelve estricta lo que fuerza la convergencia.)

(d) $M_4(x) = x-x^2$.

Análogamente:

```julia
M₄(x) = x - x^2

n_4 = 2
x0s_4 = [-1:0.2:2...]

colores_4 = paleta_colores(length(x0s_4))

gráfica_4 = análisis_gráfico(M₄, n_4, x0s_4, linecolors = colores_4)
xlims!(-2, 2)
ylims!(-2, 1)
```

Se observan dos regímenes: uno cuando las condiciones iniciales están afuera del interior de la parábola, en el que las órbitas divergen y el otro, al interior de y en la parábola en el que el único punto fijo funje de atractor. Esto significa que el punto fijo es neutral.

Que el punto fijo es único se encuentra inmediatamente de aplicar la definición:

$$ M_4(x) = x \iff x - x^2 = x \iff x^2 = 0 \iff x_0 = 0. $$

## Ejercicio 2

(a) Consideren el mapeo $F(x) = x^2-2$ definido en $-2 \leq x \leq 2$. A partir de una condición al azar, construyan una órbita muy larga, por ejemplo, de $20\,000$ iterados o más. Obtengan el histograma de frecuencias (normalizado) que la órbita visita.

Definamos el mapeo:

```julia
F(x) = begin @assert (abs(x) <= 2); x^2 - 2 end
```

Podemos demostrar que en efecto está bien definido utilizando aritmética de intervalos:

$$f[[-2, 2]] = [-2, 2]^2 - 2 = [0, 4] - 2 = [-2, 2]$$

Para muestrear una distribución homogénea en el intervalo $[-2, 2)$, podemos utilizar la función ```rand```.
Ésta función devuelve un número aleatorio tomado de una distribución homogénea en $[0, 1)$.
Multiplicando el resultado por cuatro y restando a éste 2, tenemos una distribución homogénea en $[-2, 2)$. 
Esta distribución es idéntica a la homogénea en $[-2, 2]$ salvo por un conjunto de medida cero. ({2})

Una generalización ligera es la distribución uniforme en el intervalo $[a, b)$, en el que se multiplica al resultado de ```rand``` por $b - a$ y a éste se le suma $a$.

```julia
uniforme(a, b) = (b - a)*rand() + a
```

Podemos utilizar la paquetería ```Plots``` para realizar histogramas sencillos;

```julia
#Tomemos un millón de iteraciones:
muestreo_F = iterados(F, 1_000_000)(uniforme(-2, 2))

#Y se puede normalizar el histograma a una función de distribución de probabilidad mediante ```normalize = :pdf```:
histogram(muestreo_F, normalize = :pdf, label = "")
```

Se observa que los puntos fijos del mapeo de cierta forma, son "atractivos en estadística" para las órbitas de un punto aleatorio en el dominio.
El término "atractivo en estadística" se ocupa dado que estrictamente los puntos fijos son repulsores, como lo demuestra el análisis de la primera derivada.

(b) Repitan el ejercicio anterior para el mapeo $G(x) = 2x\mod 1$, definido en el intervalo $x\in[0,1]$.

Definimos el mapeo: 

```julia
G(x) = begin @assert 0 <= x <= 1; mod(2*x, 1); end
```

El mapeo está bien definido por la inclusión de la aritmética modular.

Realicemos el análisis:

```julia
#Tomemos un millón de iteraciones:
muestreo_G = iterados(G, 1_000_000)(uniforme(0, 1))

#Y hagamos el histograma:
histogram(muestreo_G, normalize = :pdf, label = "")
```

De nuevo, aunque estrictamente los puntos fijos del mapeo (los extremos del dominio) son repulsores, uno de ellos "atrae en estadística" las órbitas de un punto tomado al azar en el dominio.

(c) ¿Qué conclusión podemos sacar de los histogramas para ambos mapeos?

Los histogramas que realizamos, al normalizarlos como una función de densidad de probabilidad, nos dice la probabilidad a lo largo de una órbita de explorar el dominio del mapeo (su espacio fase). 

Más allá de la curiosidad de que puntos repulsores en un dominio acotado puedan atraer las órbitas de  puntos al azar, que la distribución de probabilidad que obtenemos de los mapeos no sea uniforme a pesar de empezar con una distribución uniforme, nos dice que ¡los mapeos no son ergódicos!
No todos los puntos del espacio fase tienen igual probabilidad de ser visitados.

## Ejercicio 3

(a) Usando lo que hicieron en la Tarea 1, incluyan lo que desarrollaron para los números `Dual`es en un módulo `NumDual` de Julia ([ver la documentación aquí](https://docs.julialang.org/en/v1.3/manual/modules/)). En particular, el módulo debe exportar el tipo `Dual` y la función `var_dual`, al menos. El archivo con el módulo lo deben incluir en un archivo ".jl" en su propio directorio de tareas. Carguen el módulo en este notebook, usando

```julia
include("nombre_archivo.jl")
using NumDual
```

El módulo respectivo está contenido en el directorio ```tareas/CSGA``` con el nombre ```NumDual.jl```:

```julia
include("NumDual.jl")
using Main.NumDual
```

(b) Escriban una función que implemente el método de Newton para funciones en una dimensión. La derivada que se requiere debe ser calculada a través de los números duales. Obtengan un cero de $f(x) = x^3 - 8$, como test de que la implementación es correcta.

Podemos implementar el método de Newton (unidimensional) de la siguiente forma:

```julia
"""
    Newton(f::Function, x0::Number, número_iteraciones::Int = 1000)

Implementación del método de Newton unidimensional usando números duales.
Dada una adivinanza inicial \$x_0\$, aproxima la raíz de la ecuación \$f(x) = 0\$ mediante el número de iteraciones determinado.
"""
function Newton(f::Function, x0::Number, número_iteraciones::Int = 100)
    
    x = var_Dual(x0)
    
    for i in 1:número_iteraciones
        
        y = f(x)
        
        x -= y.p/y.d
    end
    
    return x.p
end
```

Probemos calculando una raíz de $f(x)$:

```julia
#Definiendo la función:
f(x) = x^3 - 8

#Calculando un cero:
x0 = Newton(f, 10)
```

Comprobemos que en realidad es raíz:

```julia
f(x0)
```

(c) Encuentren los puntos fijos del mapeo $F(x) = x^2 - 1.1$ usando la función que implementaron para el método de Newton.

Podemos implementar una función que calcule los puntos fijos:

```julia
"""
    puntos_fijos(f::Function, x0s::Array{T, 1}, número_iteraciones::Int = 1000) where {T <: Number}

Dada una función \$f\$ y un arreglo de condiciones iniciales, ```x0s```, busca los puntos fijos (i.e. soluciones a la ecuación \$ f(x) - x = 0\$) usando el método de Newton.
Devuelve un arreglo de los puntos fijos encontrados con las condiciones iniciales dadas.
"""
function puntos_fijos(f::Function, x0s::Array{T, 1}, número_iteraciones::Int = 1000) where {T <: Number}
    
    puntos_fijos = x -> f(x) - x
    
    convergencia = [Newton(puntos_fijos, x0, número_iteraciones) for x0 in x0s]
    unique!(convergencia)
    
    return convergencia
end
```

Definimos la función:

```julia
F(x) = x^2 - 1.1
```

Y calculamos los puntos fijos. En principio, al este mapeo definir una ecuación cuadrática, sólo existen, cuanto más, dos puntos fijos; por lo que sólo dos condiciones  iniciales (adecuadas) deberían de bastar para encontrar los puntos:

```julia
F1 = puntos_fijos(x->x^2 - 1.1, [-1, 1])
```

Verifiquemos que son puntos fijos:

```julia
F.(F1)
```

(d) Encuentren los puntos *de periodo 2* para el mapeo $F(x) = x^2 - 1.1$ usando la función que implementaron para el método de Newton.

De manera análoga, podemos definir una función que calcule los puntos de periodo arbitrario. (La función anterior es un caso especial de este, para cuando el orden del periodo de los puntos es uno.)

```julia
"""
    puntos_periodo(f::Function, n::Int, x0s::Array{T, 1}, número_iteraciones::Int = 1000) where {T <: Number}

Dada una función \$f\$ y un arreglo de condiciones iniciales, ```x0s```, busca los puntos de periodo \$n\$ (i.e. soluciones a la ecuación \$ f^{(n)}(x) - x = 0\$) usando el método de Newton.
Devuelve un arreglo de los puntos de periodo \$n\$ encontrados con las condiciones iniciales dadas.
"""
function puntos_periodo(f::Function, n::Int, x0s::Array{T, 1}, número_iteraciones::Int = 1000) where {T <: Number}
    
    @assert n > 0
    
    puntos_periodo_n = x -> iterar(f, n, x) - x
    
    convergencia = [Newton(puntos_periodo_n, x0, número_iteraciones) for x0 in x0s]
    unique!(convergencia)
    
    return convergencia
end
```

Usemos lo que acabamos de definir para calcular los puntos de periodo dos. Dado que la segunda iteración define una cuártica, existen cuanto más, cuatro puntos de periodo dos:

```julia
F2 = puntos_periodo(F, 2, [-10, -1, 0, 1, 10])
```

Comprobemos que en efecto son puntos de periodo dos:

```julia
iterar(F, 2).(F2)
```

(e) Usen números duales para mostrar que los puntos de periodo 2 para el mapeo $F(x) = x^2 - 1.1$ son linealmente estables (atractivos).

Basta convertir los valores anteriores a sus ```var_Dual```es correspondientes, evaluar $F^{(2)}(x)$ en los duales correspondientes y examinar la derivada:

```julia
derivada.(iterar(F, 2).(var_Dual.(F2)))
```

Esto quiere decir que hay un par de puntos atractores y un par de puntos respulsores de periodo 2.

## Ejercicio 4

(a) El método de Newton es iterativo, y en ese sentido se puede considerar como un mapeo dado por
\begin{equation}
z_{n+1} = N(z_n) = z_n - \frac{f(z_n)}{f'(z_n)}.
\end{equation}
Vamos a considerar la función $f(z) = z^3-1$, e iteraciones del mapeo $N(z)$, con $z\in\mathbb{C}$. Es claro que los ceros de $f(z)$, es decir, las $z^*$ tales que $f(z^*)=0$
tienen la propiedad de que $N(z^*)=z_*$. En este caso concreto los ceros los podemos escribir como $z^*_r = \exp(i 2\pi r/3)$, con $r=0, 1, 2$.

La idea es considerar *muchas* condiciones iniciales $z_0\in[-1,1]\times[-1,1]$, y para cada condición inicial iteraremos muchas veces el mapeo, por ejemplo, $n=10000$ veces. La idea es asignarle a cada condición inicial un color (azul, verde o rojo) según el punto al que converja, o al punto al que más se acerque $z_n$. Dibujen el mapa de colores que se obtiene.

(b) En el mismo espíritu que en el inciso (a), iteren muchas condiciones iniciales para el mapeo
\begin{equation}
z_{n+1} = z_n - a\frac{f(z_n)}{f'(z_n)},
\end{equation}
para la misma función $f(z)$, con $a=2$.

*Nota:* Conviene guardar tres vectores (de condiciones iniciales), y a cada uno se le asignará un color. Para graficar, dado que estamos en los complejos, se graficará la parte real y la parte imaginaria de cada condición inicial.

```julia
```

## Ejercicio 5

Consideremos ahora el triángulo definido por los tres puntos $A=(1, 0)$, $B=(\cos(7\pi/6), \sin(7\pi/6))$ y $C=(\cos(11\pi/6), \sin(11\pi/6))$, y *cualquier* otro punto $X_0$ en $[-1,1]\times[-1,1]$. Consideraremos además un dado (no cargado) que usaremos para generar números aleatorios del 1 al 6 (con `rand(1:6)`).

(a) Definan una regla, la que quieran, que asigne dos salidas distintas del dado (por ejemplo, 1 y 5) a cada uno de los tres vértices del triángulo.

(b) A partir de un punto $X$, definan el mapeo que, para cada tiro del dado $d$, hace que el punto $X$ sea mapeado al punto medio de $X$ y el vértice del triángulo asignado en (a).

(c) Obtengan *el atractor* del mapeo para una sola condición inicial, esto es, iteren muchísimas veces el mapeo ($n=100000$) y pinten la secuencia de los iterados.

(d) ¿Qué pasa si empiezan con otras condiciones iniciales, incluso fuera de $[-1,1]\times[-1,1]$?

```julia
```

## Ejercicio 6

Vamos a considerar el siguiente mapeo lineal, en dos dimensiones, dado por

\begin{equation}
B(x_{n+1}, y_{n+1} ) =
\left( \begin{array}{c} x_{n+1} \\ y_{n+1} \end{array} \right) =
\left(\begin{array}{cc} a & b\\ c & d \end{array}\right)
\left( \begin{array}{c} x_{n} \\ y_{n} \end{array} \right) +
\left( \begin{array}{c} 0 \\ f \end{array} \right).
\end{equation}

Los coeficientes que aparecen en el mapeo se eligirán de manera aleatoria, con
probabilidad $p$, de acuerdo con la siguiente tabla:

|     p     |     a     |     b     |     c     |     d     |     f     |
|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|
|   0.01    |     0     |     0     |     0     |    0.16   |   0    |
|   0.85    |  0.85     |     0.04  |   -0.04   |    0.85   |   1.6     |
|   0.07    |  0.2      |    -0.26  |    0.23   |    0.22   |   1.6     |
|   0.07    | -0.15     |     0.28  |    0.26   |    0.24   |   0.44    |

Dibujen (en verde, usando `markerstrokecolor=:green`) el atractor del mapeo.

```julia
```
